<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>7分 → 3分 自動タイマー</title>
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#22c55e;
      --muted:#94a3b8;
      --glass: rgba(255,255,255,0.04);
    }
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", sans-serif;
      background: linear-gradient(180deg, #071026 0%, #071b2e 100%);
      color:#e6eef8;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      box-sizing:border-box;
    }
    .card{
      width:100%;
      max-width:520px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:14px;
      padding:22px;
      box-shadow: 0 8px 30px rgba(2,6,23,0.6);
      border: 1px solid rgba(255,255,255,0.04);
    }
    h1{margin:0 0 8px 0; font-size:20px}
    p.sub{margin:0 0 18px 0; color:var(--muted); font-size:13px}
    .display{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      background:var(--glass);
      padding:18px;
      border-radius:10px;
      margin-bottom:18px;
    }
    .time{
      font-size:44px;
      font-weight:700;
      letter-spacing:1px;
    }
    .phase{
      text-align:right;
    }
    .small{font-size:13px; color:var(--muted)}
    .controls{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    button{
      appearance:none;
      border:0;
      padding:10px 14px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
    }
    .btn-start{background:linear-gradient(90deg,#16a34a,#22c55e); color:#021214}
    .btn-stop{background:#e11d48; color:#fff}
    .btn-pause{background:#f59e0b; color:#021214}
    .btn-reset{background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); padding:8px 10px}
    .progress{
      height:8px;
      background: rgba(255,255,255,0.04);
      border-radius:999px;
      overflow:hidden;
      margin-top:12px;
    }
    .progress > i{
      display:block;
      height:100%;
      width:0%;
      background: linear-gradient(90deg,#22c55e,#06b6d4);
      transition: width 0.15s linear;
    }
    footer{margin-top:12px; color:var(--muted); font-size:12px; text-align:right}
    @media (max-width:420px){
      .time{font-size:36px}
      .card{padding:16px}
    }
  </style>
</head>
<body>
  <div class="card" role="application" aria-labelledby="title">
    <h1 id="title">7分 → 3分 自動タイマー</h1>
    <p class="sub">「スタート」を押すと 7分 が始まり、終了でアラーム → 自動で 3分 が始まり、終了でアラームして停止します。</p>

    <div class="display" aria-live="polite">
      <div>
        <div class="time" id="time">07:00</div>
        <div class="small" id="desc">停止中</div>
      </div>
      <div class="phase" aria-hidden="true">
        <div class="small">フェーズ</div>
        <div id="phaseLabel" style="font-weight:700; margin-top:6px">—</div>
      </div>
    </div>

    <div class="progress" aria-hidden="true" title="進捗">
      <i id="progressBar" style="width:0%"></i>
    </div>

    <div class="controls" style="margin-top:12px;">
      <button id="startBtn" class="btn-start">スタート</button>
      <button id="pauseBtn" class="btn-pause" disabled>一時停止</button>
      <button id="stopBtn" class="btn-stop" disabled>停止</button>
      <button id="resetBtn" class="btn-reset">リセット</button>
    </div>

    <footer>キーボード: Enter = スタート / Space = 一時停止切替 / Esc = 停止</footer>
  </div>

  <script>
    // フェーズ設定（秒）
    const PHASES = [
      { seconds: 7 * 60, label: "7分タイマー" },
      { seconds: 3 * 60, label: "3分タイマー" }
    ];

    // DOM
    const timeEl = document.getElementById('time');
    const descEl = document.getElementById('desc');
    const phaseLabelEl = document.getElementById('phaseLabel');
    const progressBar = document.getElementById('progressBar');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');

    // 状態
    let running = false;
    let paused = false;
    let phaseIndex = 0;
    let phaseStartPerf = 0; // performance.now() at phase start
    let pausedElapsed = 0;  // elapsed seconds when paused
    let rafId = null;

    // AudioContext を遅延初期化（ユーザー操作が必要）
    let audioCtx = null;
    function ensureAudioCtx(){
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      return audioCtx;
    }

    // ビープ音を鳴らす（非同期）
    async function playBeepSequence(){
      const ctx = ensureAudioCtx();
      // 2発ビープ（短→短）で注意を引く
      playBeep(ctx, 0.14, 880, 0.02);
      await sleep(160);
      playBeep(ctx, 0.12, 660, 0.02);
    }

    function playBeep(ctx, durationSec = 0.15, freq = 880, attack = 0.01){
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = freq;
      g.gain.value = 0;
      o.connect(g);
      g.connect(ctx.destination);
      const now = ctx.currentTime;
      g.gain.cancelScheduledValues(now);
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(0.8, now + attack);
      g.gain.exponentialRampToValueAtTime(0.001, now + durationSec);
      o.start(now);
      o.stop(now + durationSec + 0.02);
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    // 時間フォーマット mm:ss
    function formatTime(sec){
      if(sec < 0) sec = 0;
      const s = Math.ceil(sec);
      const mm = Math.floor(s / 60).toString().padStart(2,'0');
      const ss = (s % 60).toString().padStart(2,'0');
      return `${mm}:${ss}`;
    }

    function updateUI(remainingSec, totalSec){
      timeEl.textContent = formatTime(remainingSec);
      phaseLabelEl.textContent = PHASES[phaseIndex]?.label ?? '—';
      // desc
      descEl.textContent = running ? (paused ? '一時停止中' : '動作中') : '停止中';
      // progress
      const pct = totalSec ? Math.max(0, Math.min(100, (1 - remainingSec / totalSec) * 100)) : 0;
      progressBar.style.width = pct + '%';
      // buttons
      startBtn.disabled = running && !paused;
      pauseBtn.disabled = !running;
      stopBtn.disabled = !running;
    }

    // 開始
    function startSequence(){
      if(running && !paused) return; // 既に動いてる
      // 初回開始または再開
      if(!running){
        phaseIndex = 0;
        startPhase(phaseIndex);
      } else if(paused){
        // 再開：pausedElapsed に基づき start time を調整
        phaseStartPerf = performance.now() - pausedElapsed * 1000;
        paused = false;
        descEl.textContent = '動作中';
        animate();
      }
      running = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
    }

    function startPhase(index){
      phaseIndex = index;
      pausedElapsed = 0;
      phaseStartPerf = performance.now();
      running = true;
      paused = false;
      updateUI(PHASES[phaseIndex].seconds, PHASES[phaseIndex].seconds);
      // ループ開始
      cancelAnimationFrame(rafId);
      animate();
    }

    function pauseToggle(){
      if(!running) return;
      if(!paused){
        // pause now
        pausedElapsed = (performance.now() - phaseStartPerf) / 1000;
        paused = true;
        cancelAnimationFrame(rafId);
      } else {
        // resume
        phaseStartPerf = performance.now() - pausedElapsed * 1000;
        paused = false;
        animate();
      }
      updateUI(getRemaining(), PHASES[phaseIndex].seconds);
    }

    function stopAll(){
      running = false;
      paused = false;
      cancelAnimationFrame(rafId);
      updateUI(PHASES[0].seconds, PHASES[0].seconds);
    }

    function resetAll(){
      stopAll();
      phaseIndex = 0;
      pausedElapsed = 0;
      updateUI(PHASES[0].seconds, PHASES[0].seconds);
    }

    function getElapsed(){
      if(!running) return 0;
      if(paused) return pausedElapsed;
      return (performance.now() - phaseStartPerf) / 1000;
    }
    function getRemaining(){
      if(!PHASES[phaseIndex]) return 0;
      return PHASES[phaseIndex].seconds - getElapsed();
    }

    // 毎フレーム更新
    function animate(){
      const remaining = getRemaining();
      updateUI(remaining, PHASES[phaseIndex].seconds);

      if(remaining <= 0){
        // フェーズ終了
        // アラームを鳴らす → 次フェーズへ（または完了）
        (async () => {
          try {
            await ensureAudioStart(); // iOS などで最初のユーザー操作を保証
            await playBeepSequence();
          } catch(e){}
        })();

        // 次のフェーズに進むかチェック
        if(phaseIndex + 1 < PHASES.length){
          // 次フェーズを即座に開始
          phaseIndex++;
          phaseStartPerf = performance.now();
          pausedElapsed = 0;
          // 続けて animate する
          rafId = requestAnimationFrame(animate);
        } else {
          // 全フェーズ終了 → 停止
          running = false;
          paused = false;
          updateUI(0, PHASES[phaseIndex].seconds);
          // 最後のアラームはすでに鳴らしたので何もしない
        }
        return;
      }

      // 続行
      rafId = requestAnimationFrame(animate);
    }

    // iOS 等のオーディオ再生許可確保（ユーザー操作後に AudioContext resume）
    async function ensureAudioStart(){
      const ctx = ensureAudioCtx();
      if(ctx.state === 'suspended'){
        try { await ctx.resume(); } catch(e){}
      }
    }

    // イベント
    startBtn.addEventListener('click', async () => {
      ensureAudioCtx(); // ユーザーアクションで初期化
      await ensureAudioStart();
      startSequence();
    });
    pauseBtn.addEventListener('click', () => {
      pauseToggle();
    });
    stopBtn.addEventListener('click', () => {
      stopAll();
    });
    resetBtn.addEventListener('click', () => {
      resetAll();
    });

    // キーボードショートカット
    document.addEventListener('keydown', (e) => {
      if(e.key === 'Enter'){
        startBtn.click();
      } else if(e.code === 'Space'){
        e.preventDefault();
        if(!pauseBtn.disabled) pauseBtn.click();
      } else if(e.key === 'Escape'){
        stopBtn.click();
      }
    });

    // 初期 UI
    resetAll();

    // Page visibility: hidden 時は RAF の負荷を下げる（省電力）
    document.addEventListener('visibilitychange', () => {
      if(document.hidden){
        cancelAnimationFrame(rafId);
      } else {
        if(running && !paused) animate();
      }
    });
  </script>
</body>
</html>
